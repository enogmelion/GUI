// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Sink0MQprocotol

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "NetworkSinkProcotol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace OpenEphys {

namespace {

const ::google::protobuf::Descriptor* DoubleMatrix_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DoubleMatrix_reflection_ = NULL;
const ::google::protobuf::Descriptor* Spike_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Spike_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChannelData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChannelData_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChannelsData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChannelsData_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_Sink0MQprocotol() {
  protobuf_AddDesc_Sink0MQprocotol();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Sink0MQprocotol");
  GOOGLE_CHECK(file != NULL);
  DoubleMatrix_descriptor_ = file->message_type(0);
  static const int DoubleMatrix_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DoubleMatrix, rows_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DoubleMatrix, cols_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DoubleMatrix, data_),
  };
  DoubleMatrix_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DoubleMatrix_descriptor_,
      DoubleMatrix::default_instance_,
      DoubleMatrix_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DoubleMatrix, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DoubleMatrix, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DoubleMatrix));
  Spike_descriptor_ = file->message_type(1);
  static const int Spike_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, timestamp_software_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, nchannels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, nsamples_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, sortedid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, electrodeid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, pcproj_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, samplingfrequencyhz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, gain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, threshold_),
  };
  Spike_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Spike_descriptor_,
      Spike::default_instance_,
      Spike_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spike, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Spike));
  ChannelData_descriptor_ = file->message_type(2);
  static const int ChannelData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelData, channel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelData, nsamples_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelData, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelData, samplingfrequencyhz_),
  };
  ChannelData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChannelData_descriptor_,
      ChannelData::default_instance_,
      ChannelData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChannelData));
  ChannelsData_descriptor_ = file->message_type(3);
  static const int ChannelsData_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelsData, nchannels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelsData, channels_),
  };
  ChannelsData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChannelsData_descriptor_,
      ChannelsData::default_instance_,
      ChannelsData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelsData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelsData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChannelsData));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Sink0MQprocotol);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DoubleMatrix_descriptor_, &DoubleMatrix::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Spike_descriptor_, &Spike::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChannelData_descriptor_, &ChannelData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChannelsData_descriptor_, &ChannelsData::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Sink0MQprocotol() {
  delete DoubleMatrix::default_instance_;
  delete DoubleMatrix_reflection_;
  delete Spike::default_instance_;
  delete Spike_reflection_;
  delete ChannelData::default_instance_;
  delete ChannelData_reflection_;
  delete ChannelsData::default_instance_;
  delete ChannelsData_reflection_;
}

void protobuf_AddDesc_Sink0MQprocotol() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017Sink0MQprocotol\022\tOpenEphys\"<\n\014DoubleMa"
    "trix\022\014\n\004rows\030\001 \002(\r\022\014\n\004cols\030\002 \002(\r\022\020\n\004data"
    "\030\003 \003(\001B\002\020\001\"\215\002\n\005Spike\022\021\n\ttimestamp\030\001 \002(\020\022"
    "\032\n\022timestamp_software\030\002 \002(\020\022\016\n\006source\030\003 "
    "\002(\005\022\021\n\tnChannels\030\004 \002(\005\022\020\n\010nSamples\030\005 \002(\005"
    "\022\020\n\010sortedId\030\006 \002(\005\022\023\n\013electrodeID\030\007 \002(\005\022"
    "\021\n\005color\030\010 \003(\005B\002\020\001\022\016\n\006pcProj\030\t \003(\002\022\033\n\023sa"
    "mplingFrequencyHz\030\n \002(\005\022\020\n\004data\030\013 \003(\005B\002\020"
    "\001\022\020\n\004gain\030\014 \003(\005B\002\020\001\022\025\n\tthreshold\030\r \003(\005B\002"
    "\020\001\"_\n\013ChannelData\022\017\n\007channel\030\001 \002(\005\022\020\n\010nS"
    "amples\030\002 \002(\005\022\020\n\004data\030\003 \003(\005B\002\020\001\022\033\n\023sampli"
    "ngFrequencyHz\030\004 \002(\005\"K\n\014ChannelsData\022\021\n\tn"
    "Channels\030\001 \002(\005\022(\n\010channels\030\002 \003(\0132\026.OpenE"
    "phys.ChannelData", 536);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Sink0MQprocotol", &protobuf_RegisterTypes);
  DoubleMatrix::default_instance_ = new DoubleMatrix();
  Spike::default_instance_ = new Spike();
  ChannelData::default_instance_ = new ChannelData();
  ChannelsData::default_instance_ = new ChannelsData();
  DoubleMatrix::default_instance_->InitAsDefaultInstance();
  Spike::default_instance_->InitAsDefaultInstance();
  ChannelData::default_instance_->InitAsDefaultInstance();
  ChannelsData::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Sink0MQprocotol);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Sink0MQprocotol {
  StaticDescriptorInitializer_Sink0MQprocotol() {
    protobuf_AddDesc_Sink0MQprocotol();
  }
} static_descriptor_initializer_Sink0MQprocotol_;

// ===================================================================

#ifndef _MSC_VER
const int DoubleMatrix::kRowsFieldNumber;
const int DoubleMatrix::kColsFieldNumber;
const int DoubleMatrix::kDataFieldNumber;
#endif  // !_MSC_VER

DoubleMatrix::DoubleMatrix()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DoubleMatrix::InitAsDefaultInstance() {
}

DoubleMatrix::DoubleMatrix(const DoubleMatrix& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DoubleMatrix::SharedCtor() {
  _cached_size_ = 0;
  rows_ = 0u;
  cols_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DoubleMatrix::~DoubleMatrix() {
  SharedDtor();
}

void DoubleMatrix::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DoubleMatrix::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DoubleMatrix::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DoubleMatrix_descriptor_;
}

const DoubleMatrix& DoubleMatrix::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Sink0MQprocotol();
  return *default_instance_;
}

DoubleMatrix* DoubleMatrix::default_instance_ = NULL;

DoubleMatrix* DoubleMatrix::New() const {
  return new DoubleMatrix;
}

void DoubleMatrix::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rows_ = 0u;
    cols_ = 0u;
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DoubleMatrix::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 rows = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rows_)));
          set_has_rows();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_cols;
        break;
      }

      // required uint32 cols = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cols:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cols_)));
          set_has_cols();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // repeated double data = 3 [packed = true];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_data())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 26, input, this->mutable_data())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DoubleMatrix::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 rows = 1;
  if (has_rows()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rows(), output);
  }

  // required uint32 cols = 2;
  if (has_cols()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cols(), output);
  }

  // repeated double data = 3 [packed = true];
  if (this->data_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_data_cached_byte_size_);
  }
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDoubleNoTag(
      this->data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DoubleMatrix::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 rows = 1;
  if (has_rows()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->rows(), target);
  }

  // required uint32 cols = 2;
  if (has_cols()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->cols(), target);
  }

  // repeated double data = 3 [packed = true];
  if (this->data_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      3,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _data_cached_byte_size_, target);
  }
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleNoTagToArray(this->data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DoubleMatrix::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 rows = 1;
    if (has_rows()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rows());
    }

    // required uint32 cols = 2;
    if (has_cols()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cols());
    }

  }
  // repeated double data = 3 [packed = true];
  {
    int data_size = 0;
    data_size = 8 * this->data_size();
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _data_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DoubleMatrix::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DoubleMatrix* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DoubleMatrix*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DoubleMatrix::MergeFrom(const DoubleMatrix& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rows()) {
      set_rows(from.rows());
    }
    if (from.has_cols()) {
      set_cols(from.cols());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DoubleMatrix::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DoubleMatrix::CopyFrom(const DoubleMatrix& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleMatrix::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DoubleMatrix::Swap(DoubleMatrix* other) {
  if (other != this) {
    std::swap(rows_, other->rows_);
    std::swap(cols_, other->cols_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DoubleMatrix::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DoubleMatrix_descriptor_;
  metadata.reflection = DoubleMatrix_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Spike::kTimestampFieldNumber;
const int Spike::kTimestampSoftwareFieldNumber;
const int Spike::kSourceFieldNumber;
const int Spike::kNChannelsFieldNumber;
const int Spike::kNSamplesFieldNumber;
const int Spike::kSortedIdFieldNumber;
const int Spike::kElectrodeIDFieldNumber;
const int Spike::kColorFieldNumber;
const int Spike::kPcProjFieldNumber;
const int Spike::kSamplingFrequencyHzFieldNumber;
const int Spike::kDataFieldNumber;
const int Spike::kGainFieldNumber;
const int Spike::kThresholdFieldNumber;
#endif  // !_MSC_VER

Spike::Spike()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Spike::InitAsDefaultInstance() {
}

Spike::Spike(const Spike& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Spike::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = GOOGLE_LONGLONG(0);
  timestamp_software_ = GOOGLE_LONGLONG(0);
  source_ = 0;
  nchannels_ = 0;
  nsamples_ = 0;
  sortedid_ = 0;
  electrodeid_ = 0;
  samplingfrequencyhz_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Spike::~Spike() {
  SharedDtor();
}

void Spike::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Spike::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Spike::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Spike_descriptor_;
}

const Spike& Spike::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Sink0MQprocotol();
  return *default_instance_;
}

Spike* Spike::default_instance_ = NULL;

Spike* Spike::New() const {
  return new Spike;
}

void Spike::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestamp_ = GOOGLE_LONGLONG(0);
    timestamp_software_ = GOOGLE_LONGLONG(0);
    source_ = 0;
    nchannels_ = 0;
    nsamples_ = 0;
    sortedid_ = 0;
    electrodeid_ = 0;
  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    samplingfrequencyhz_ = 0;
  }
  color_.Clear();
  pcproj_.Clear();
  data_.Clear();
  gain_.Clear();
  threshold_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Spike::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required sfixed64 timestamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_timestamp_software;
        break;
      }

      // required sfixed64 timestamp_software = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_timestamp_software:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, &timestamp_software_)));
          set_has_timestamp_software();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_source;
        break;
      }

      // required int32 source = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_source:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &source_)));
          set_has_source();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_nChannels;
        break;
      }

      // required int32 nChannels = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nChannels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nchannels_)));
          set_has_nchannels();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_nSamples;
        break;
      }

      // required int32 nSamples = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nSamples:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nsamples_)));
          set_has_nsamples();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_sortedId;
        break;
      }

      // required int32 sortedId = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sortedId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sortedid_)));
          set_has_sortedid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_electrodeID;
        break;
      }

      // required int32 electrodeID = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_electrodeID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &electrodeid_)));
          set_has_electrodeid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_color;
        break;
      }

      // repeated int32 color = 8 [packed = true];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_color())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 66, input, this->mutable_color())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_pcProj;
        break;
      }

      // repeated float pcProj = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pcProj:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 77, input, this->mutable_pcproj())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_pcproj())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_pcProj;
        if (input->ExpectTag(80)) goto parse_samplingFrequencyHz;
        break;
      }

      // required int32 samplingFrequencyHz = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_samplingFrequencyHz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &samplingfrequencyhz_)));
          set_has_samplingfrequencyhz();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_data;
        break;
      }

      // repeated int32 data = 11 [packed = true];
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_data())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 90, input, this->mutable_data())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_gain;
        break;
      }

      // repeated int32 gain = 12 [packed = true];
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_gain())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 98, input, this->mutable_gain())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_threshold;
        break;
      }

      // repeated int32 threshold = 13 [packed = true];
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_threshold())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 106, input, this->mutable_threshold())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Spike::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required sfixed64 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(1, this->timestamp(), output);
  }

  // required sfixed64 timestamp_software = 2;
  if (has_timestamp_software()) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(2, this->timestamp_software(), output);
  }

  // required int32 source = 3;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->source(), output);
  }

  // required int32 nChannels = 4;
  if (has_nchannels()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->nchannels(), output);
  }

  // required int32 nSamples = 5;
  if (has_nsamples()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->nsamples(), output);
  }

  // required int32 sortedId = 6;
  if (has_sortedid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->sortedid(), output);
  }

  // required int32 electrodeID = 7;
  if (has_electrodeid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->electrodeid(), output);
  }

  // repeated int32 color = 8 [packed = true];
  if (this->color_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(8, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_color_cached_byte_size_);
  }
  for (int i = 0; i < this->color_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->color(i), output);
  }

  // repeated float pcProj = 9;
  for (int i = 0; i < this->pcproj_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      9, this->pcproj(i), output);
  }

  // required int32 samplingFrequencyHz = 10;
  if (has_samplingfrequencyhz()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->samplingfrequencyhz(), output);
  }

  // repeated int32 data = 11 [packed = true];
  if (this->data_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(11, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_data_cached_byte_size_);
  }
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->data(i), output);
  }

  // repeated int32 gain = 12 [packed = true];
  if (this->gain_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(12, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_gain_cached_byte_size_);
  }
  for (int i = 0; i < this->gain_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->gain(i), output);
  }

  // repeated int32 threshold = 13 [packed = true];
  if (this->threshold_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(13, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_threshold_cached_byte_size_);
  }
  for (int i = 0; i < this->threshold_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->threshold(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Spike::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required sfixed64 timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed64ToArray(1, this->timestamp(), target);
  }

  // required sfixed64 timestamp_software = 2;
  if (has_timestamp_software()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed64ToArray(2, this->timestamp_software(), target);
  }

  // required int32 source = 3;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->source(), target);
  }

  // required int32 nChannels = 4;
  if (has_nchannels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->nchannels(), target);
  }

  // required int32 nSamples = 5;
  if (has_nsamples()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->nsamples(), target);
  }

  // required int32 sortedId = 6;
  if (has_sortedid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->sortedid(), target);
  }

  // required int32 electrodeID = 7;
  if (has_electrodeid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->electrodeid(), target);
  }

  // repeated int32 color = 8 [packed = true];
  if (this->color_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      8,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _color_cached_byte_size_, target);
  }
  for (int i = 0; i < this->color_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->color(i), target);
  }

  // repeated float pcProj = 9;
  for (int i = 0; i < this->pcproj_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(9, this->pcproj(i), target);
  }

  // required int32 samplingFrequencyHz = 10;
  if (has_samplingfrequencyhz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->samplingfrequencyhz(), target);
  }

  // repeated int32 data = 11 [packed = true];
  if (this->data_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      11,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _data_cached_byte_size_, target);
  }
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->data(i), target);
  }

  // repeated int32 gain = 12 [packed = true];
  if (this->gain_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      12,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _gain_cached_byte_size_, target);
  }
  for (int i = 0; i < this->gain_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->gain(i), target);
  }

  // repeated int32 threshold = 13 [packed = true];
  if (this->threshold_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      13,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _threshold_cached_byte_size_, target);
  }
  for (int i = 0; i < this->threshold_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->threshold(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Spike::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required sfixed64 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // required sfixed64 timestamp_software = 2;
    if (has_timestamp_software()) {
      total_size += 1 + 8;
    }

    // required int32 source = 3;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->source());
    }

    // required int32 nChannels = 4;
    if (has_nchannels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nchannels());
    }

    // required int32 nSamples = 5;
    if (has_nsamples()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nsamples());
    }

    // required int32 sortedId = 6;
    if (has_sortedid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sortedid());
    }

    // required int32 electrodeID = 7;
    if (has_electrodeid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->electrodeid());
    }

  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    // required int32 samplingFrequencyHz = 10;
    if (has_samplingfrequencyhz()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->samplingfrequencyhz());
    }

  }
  // repeated int32 color = 8 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->color_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->color(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _color_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated float pcProj = 9;
  {
    int data_size = 0;
    data_size = 4 * this->pcproj_size();
    total_size += 1 * this->pcproj_size() + data_size;
  }

  // repeated int32 data = 11 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->data_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->data(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _data_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated int32 gain = 12 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->gain_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->gain(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _gain_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated int32 threshold = 13 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->threshold_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->threshold(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _threshold_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Spike::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Spike* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Spike*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Spike::MergeFrom(const Spike& from) {
  GOOGLE_CHECK_NE(&from, this);
  color_.MergeFrom(from.color_);
  pcproj_.MergeFrom(from.pcproj_);
  data_.MergeFrom(from.data_);
  gain_.MergeFrom(from.gain_);
  threshold_.MergeFrom(from.threshold_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_timestamp_software()) {
      set_timestamp_software(from.timestamp_software());
    }
    if (from.has_source()) {
      set_source(from.source());
    }
    if (from.has_nchannels()) {
      set_nchannels(from.nchannels());
    }
    if (from.has_nsamples()) {
      set_nsamples(from.nsamples());
    }
    if (from.has_sortedid()) {
      set_sortedid(from.sortedid());
    }
    if (from.has_electrodeid()) {
      set_electrodeid(from.electrodeid());
    }
  }
  if (from._has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (from.has_samplingfrequencyhz()) {
      set_samplingfrequencyhz(from.samplingfrequencyhz());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Spike::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Spike::CopyFrom(const Spike& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Spike::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000027f) != 0x0000027f) return false;

  return true;
}

void Spike::Swap(Spike* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(timestamp_software_, other->timestamp_software_);
    std::swap(source_, other->source_);
    std::swap(nchannels_, other->nchannels_);
    std::swap(nsamples_, other->nsamples_);
    std::swap(sortedid_, other->sortedid_);
    std::swap(electrodeid_, other->electrodeid_);
    color_.Swap(&other->color_);
    pcproj_.Swap(&other->pcproj_);
    std::swap(samplingfrequencyhz_, other->samplingfrequencyhz_);
    data_.Swap(&other->data_);
    gain_.Swap(&other->gain_);
    threshold_.Swap(&other->threshold_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Spike::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Spike_descriptor_;
  metadata.reflection = Spike_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChannelData::kChannelFieldNumber;
const int ChannelData::kNSamplesFieldNumber;
const int ChannelData::kDataFieldNumber;
const int ChannelData::kSamplingFrequencyHzFieldNumber;
#endif  // !_MSC_VER

ChannelData::ChannelData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChannelData::InitAsDefaultInstance() {
}

ChannelData::ChannelData(const ChannelData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChannelData::SharedCtor() {
  _cached_size_ = 0;
  channel_ = 0;
  nsamples_ = 0;
  samplingfrequencyhz_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChannelData::~ChannelData() {
  SharedDtor();
}

void ChannelData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ChannelData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChannelData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChannelData_descriptor_;
}

const ChannelData& ChannelData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Sink0MQprocotol();
  return *default_instance_;
}

ChannelData* ChannelData::default_instance_ = NULL;

ChannelData* ChannelData::New() const {
  return new ChannelData;
}

void ChannelData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    channel_ = 0;
    nsamples_ = 0;
    samplingfrequencyhz_ = 0;
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChannelData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 channel = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nSamples;
        break;
      }

      // required int32 nSamples = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nSamples:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nsamples_)));
          set_has_nsamples();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // repeated int32 data = 3 [packed = true];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_data())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 26, input, this->mutable_data())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_samplingFrequencyHz;
        break;
      }

      // required int32 samplingFrequencyHz = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_samplingFrequencyHz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &samplingfrequencyhz_)));
          set_has_samplingfrequencyhz();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChannelData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 channel = 1;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->channel(), output);
  }

  // required int32 nSamples = 2;
  if (has_nsamples()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nsamples(), output);
  }

  // repeated int32 data = 3 [packed = true];
  if (this->data_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_data_cached_byte_size_);
  }
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->data(i), output);
  }

  // required int32 samplingFrequencyHz = 4;
  if (has_samplingfrequencyhz()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->samplingfrequencyhz(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChannelData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 channel = 1;
  if (has_channel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->channel(), target);
  }

  // required int32 nSamples = 2;
  if (has_nsamples()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->nsamples(), target);
  }

  // repeated int32 data = 3 [packed = true];
  if (this->data_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      3,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _data_cached_byte_size_, target);
  }
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->data(i), target);
  }

  // required int32 samplingFrequencyHz = 4;
  if (has_samplingfrequencyhz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->samplingfrequencyhz(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChannelData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 channel = 1;
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channel());
    }

    // required int32 nSamples = 2;
    if (has_nsamples()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nsamples());
    }

    // required int32 samplingFrequencyHz = 4;
    if (has_samplingfrequencyhz()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->samplingfrequencyhz());
    }

  }
  // repeated int32 data = 3 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->data_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->data(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _data_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChannelData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChannelData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChannelData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChannelData::MergeFrom(const ChannelData& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_nsamples()) {
      set_nsamples(from.nsamples());
    }
    if (from.has_samplingfrequencyhz()) {
      set_samplingfrequencyhz(from.samplingfrequencyhz());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChannelData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChannelData::CopyFrom(const ChannelData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChannelData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;

  return true;
}

void ChannelData::Swap(ChannelData* other) {
  if (other != this) {
    std::swap(channel_, other->channel_);
    std::swap(nsamples_, other->nsamples_);
    data_.Swap(&other->data_);
    std::swap(samplingfrequencyhz_, other->samplingfrequencyhz_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChannelData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChannelData_descriptor_;
  metadata.reflection = ChannelData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChannelsData::kNChannelsFieldNumber;
const int ChannelsData::kChannelsFieldNumber;
#endif  // !_MSC_VER

ChannelsData::ChannelsData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChannelsData::InitAsDefaultInstance() {
}

ChannelsData::ChannelsData(const ChannelsData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChannelsData::SharedCtor() {
  _cached_size_ = 0;
  nchannels_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChannelsData::~ChannelsData() {
  SharedDtor();
}

void ChannelsData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ChannelsData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChannelsData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChannelsData_descriptor_;
}

const ChannelsData& ChannelsData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Sink0MQprocotol();
  return *default_instance_;
}

ChannelsData* ChannelsData::default_instance_ = NULL;

ChannelsData* ChannelsData::New() const {
  return new ChannelsData;
}

void ChannelsData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    nchannels_ = 0;
  }
  channels_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChannelsData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 nChannels = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nchannels_)));
          set_has_nchannels();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_channels;
        break;
      }

      // repeated .OpenEphys.ChannelData channels = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_channels()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_channels;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChannelsData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 nChannels = 1;
  if (has_nchannels()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->nchannels(), output);
  }

  // repeated .OpenEphys.ChannelData channels = 2;
  for (int i = 0; i < this->channels_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->channels(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChannelsData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 nChannels = 1;
  if (has_nchannels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->nchannels(), target);
  }

  // repeated .OpenEphys.ChannelData channels = 2;
  for (int i = 0; i < this->channels_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->channels(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChannelsData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 nChannels = 1;
    if (has_nchannels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nchannels());
    }

  }
  // repeated .OpenEphys.ChannelData channels = 2;
  total_size += 1 * this->channels_size();
  for (int i = 0; i < this->channels_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->channels(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChannelsData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChannelsData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChannelsData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChannelsData::MergeFrom(const ChannelsData& from) {
  GOOGLE_CHECK_NE(&from, this);
  channels_.MergeFrom(from.channels_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nchannels()) {
      set_nchannels(from.nchannels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChannelsData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChannelsData::CopyFrom(const ChannelsData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChannelsData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < channels_size(); i++) {
    if (!this->channels(i).IsInitialized()) return false;
  }
  return true;
}

void ChannelsData::Swap(ChannelsData* other) {
  if (other != this) {
    std::swap(nchannels_, other->nchannels_);
    channels_.Swap(&other->channels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChannelsData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChannelsData_descriptor_;
  metadata.reflection = ChannelsData_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace OpenEphys

// @@protoc_insertion_point(global_scope)